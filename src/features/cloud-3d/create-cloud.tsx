import { useEffect, useRef, useState } from 'react';import { CloudOptions } from '@/features/cloud-3d/types';const MAX_SPEED = 2;const INIT_SPEED = 32;export type Item = {    el: HTMLImageElement;    pos: {        x: number;        y: number;        z: number;    };};export function useCreateCloud(    container: HTMLElement,    elements: Array<any>,    options: CloudOptions,) {    const tickInterval = useRef<ReturnType<typeof setInterval> | null>(null);    const wrapperRef = useRef<HTMLDivElement | null>(null);    const [items, setItems] = useState<Array<Item>>([]);    const [active, setActive] = useState<boolean>(false);    const [paused, setPaused] = useState<boolean>(false);    const [mouse, setMouse] = useState({        x: 0,        y: 0,    });    const [mouse0, setMouse0] = useState({        x: 0,        y: 0,    });    const _radius = options.radius || 100;    const _depth = _radius * 2;    const _size = _radius * 1.5;    // create an image element    const _createItem = (item: any, index: number) => {        const imgEl = document.createElement('img');        imgEl.className = 'cloud--item';        imgEl.style.willChange = 'transform, opacity, filter';        imgEl.style.position = 'absolute';        imgEl.style.top = '50%';        imgEl.style.left = '50%';        imgEl.style.zIndex = `${index + 1}`;        imgEl.style.filter = 'alpha(opacity=0)';        imgEl.style.opacity = '0';        imgEl.style.transformOrigin = '50% 50%';        imgEl.style.transform = 'translate3d(-50%, -50%, 0) scale(1)';        imgEl.style.scale = '1';        imgEl.src = item.src;        imgEl.width = 200;        imgEl.style.transition = 'filter 500ms ease-in-out';        imgEl.style.filter = 'grayscale(1)';        imgEl.addEventListener('mouseover', () => {            imgEl.style.filter = 'grayscale(0)';        });        imgEl.addEventListener('mouseleave', () => {            imgEl.style.filter = 'grayscale(1)';        });        return {            el: imgEl,            pos: _computePosition(index),        };    };    // calculate position of elements    const _computePosition = (index: number, random = false) => {        const textsLength = elements.length;        // if random `true`, It means that a random appropriate place is generated, and the position will be independent of `index`        if (random) index = Math.floor(Math.random() * (textsLength + 1));        const phi = Math.acos(-1 + (2 * index + 1) / textsLength);        const theta = Math.sqrt((textsLength + 1) * Math.PI) * phi;        console.log(phi, theta);        return {            x: (_size * Math.cos(theta) * Math.sin(phi)) / 2,            y: (_size * Math.sin(theta) * Math.sin(phi)) / 2,            z: (_size * Math.cos(phi)) / 2,        };    };    const _next = () => {        if (paused) {            return;        }        // if keep `false`, pause rolling after moving mouse out area        if (!active) {            setMouse((prev) => ({                x:                    Math.abs(prev.x - mouse0.x) < 1                        ? mouse0.x                        : (mouse.x + mouse0.x) / 2,                y:                    Math.abs(prev.y - mouse0.y) < 1                        ? mouse0.y                        : (mouse.y + mouse0.y) / 2,            }));        }        const a =            -(Math.min(Math.max(-mouse.y, -_size), _size) / _radius) *            MAX_SPEED;        const b =            (Math.min(Math.max(-mouse.x, -_size), _size) / _radius) * MAX_SPEED;        // pause        // if (Math.abs(a) <= 0.01 && Math.abs(b) <= 0.01) return;        // calculate offset        const l = Math.PI / 180;        const sc = [            Math.sin(a * l),            Math.cos(a * l),            Math.sin(b * l),            Math.cos(b * l),        ];        const newItems = items.map((item: Item) => {            const rx1 = item.pos.x;            const ry1 = item.pos.y * sc[1] + item.pos.z * -sc[0];            const rz1 = item.pos.y * sc[0] + item.pos.z * sc[1];            const rx2 = rx1 * sc[3] + rz1 * sc[2];            const ry2 = ry1;            const rz2 = rz1 * sc[3] - rx1 * sc[2];            const per = (2 * _depth) / (2 * _depth + rz2); // todo            item.pos.x = rx2;            item.pos.y = ry2;            item.pos.z = rz2;            item.el.style.scale = per.toFixed(3);            let alpha: number | string = per * per - 0.25;            alpha = (alpha > 1 ? 1 : alpha).toFixed(3);            const itemEl = item.el;            const left = (item.pos.x - itemEl.offsetWidth / 2).toFixed(2);            const top = (item.pos.y - itemEl.offsetHeight / 2).toFixed(2);            const transform = `translate3d(${left}px, ${top}px, 0) scale(${itemEl.style.scale})`;            itemEl.style.transform = transform;            itemEl.style.filter = `alpha(opacity=${100 * Number(alpha)})`;            itemEl.style.opacity = alpha;            return {                el: itemEl,                pos: item.pos,            };        });        _update(newItems);    };    const _update = (_newItems: Array<Item>) => {        if (container.childNodes.length > 0) {            container.removeChild(container.childNodes[0]);        }        const $el = document.createElement('div');        $el.className = 'cloud';        $el.style.position = 'relative';        $el.style.width = `${2 * _radius}px`;        $el.style.height = `${2 * _radius}px`;        const _items: Array<Item> = [];        _newItems.forEach((element, index) => {            $el.appendChild(element.el);            _items.push(element);        });        setItems(_items);        container.appendChild($el);        wrapperRef.current = $el;    };    const _init = () => {        if (!container) return;        console.log('container exists');        if (container.childNodes.length > 0) {            container.removeChild(container.childNodes[0]);        }        setMouse0({            x: INIT_SPEED * Math.sin(Math.PI / 180),            y: INIT_SPEED * Math.sin(Math.PI / 180),        });        setMouse({            x: INIT_SPEED * Math.sin(Math.PI / 180),            y: INIT_SPEED * Math.sin(Math.PI / 180),        });        const $el = document.createElement('div');        $el.className = 'cloud';        $el.style.position = 'relative';        $el.style.width = `${2 * _radius}px`;        $el.style.height = `${2 * _radius}px`;        const _items: Array<Item> = [];        elements.forEach((element, index) => {            const item = _createItem(element, index);            $el.appendChild(item.el);            _items.push(item);        });        setItems(_items);        container.appendChild($el);        wrapperRef.current = $el;        const isTouchDevice = window.matchMedia('(hover: hover)');        if (!isTouchDevice || isTouchDevice.matches) {            // mouseover            $el.addEventListener('mouseover', () => setActive(true));            // mouseout            $el.addEventListener('mouseleave', () => setActive(false));            // mousemove            window.addEventListener('mousemove', (ev: MouseEvent) => {                ev = ev || window.event;                const rect = $el.getBoundingClientRect();                setMouse({                    x: (ev.clientX - (rect.left + rect.width / 2)) / 5,                    y: (ev.clientY - (rect.top + rect.height / 2)) / 5,                });            });        }        console.log('items length =', _items.length);        tickInterval.current = setInterval(() => {            _next();        }, 10);    };    useEffect(() => {        console.log('init');        _init();        // return () => {        //     if (tickInterval.current) clearInterval(tickInterval.current);        // };    }, [container]);    return { _init };}