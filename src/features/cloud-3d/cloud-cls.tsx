import { CloudOptions, ItemType } from '@/features/cloud-3d/types';class Cloud3d {    private readonly $container: HTMLDivElement;    private items: Array<any>;    private config: CloudOptions;    private readonly radius: number;    private readonly depth: number;    private readonly size: number;    private readonly maxSpeed: number;    private readonly initSpeed: number;    private readonly direction: number;    private readonly keep: boolean;    private readonly paused: boolean;    private $el: HTMLElement | undefined = undefined;    private active: boolean = false;    private mouseX0: number = 0;    private mouseY0: number = 0;    private mouseX: number = 0;    private mouseY: number = 0;    private interval: any;    static list: ItemType[] = [];    static _defaultConfig: CloudOptions = {        radius: 100, // rolling radius, unit `px`        maxSpeed: 'normal', // rolling max speed, optional: `slow`, `normal`(default), `fast`        initSpeed: 'normal', // rolling init speed, optional: `slow`, `normal`(default), `fast`        direction: 135, // rolling init direction, unit clockwise `deg`, optional: `0`(top) , `90`(left), `135`(right-bottom)(default)...        keep: true, // whether to keep rolling after mouse out area, optional: `false`, `true`(default)(decelerate to rolling init speed, and keep rolling with mouse)        reverseDirection: false,        useContainerInlineStyles: true,        useItemInlineStyles: true,        containerClass: 'cloud',        itemClass: 'cloud--item',        useHTML: false,    };    constructor(        container: HTMLDivElement,        items: Array<any>,        options: CloudOptions,    ) {        // if (!container || container.nodeType !== 1)        //     return new Error('Incorrect element type');        this.$container = container;        this.items = items;        this.config = { ...Cloud3d._defaultConfig, ...(options || {}) };        this.radius = this.config.radius!; // rolling radius        this.depth = 2 * this.radius!; // rolling depth        this.size = 1.5 * this.radius!; // rolling area size with mouse        this.maxSpeed = Cloud3d._getMaxSpeed(this.config.maxSpeed!); // rolling max speed        this.initSpeed = Cloud3d._getInitSpeed(this.config.initSpeed!); // rolling init speed        this.direction = this.config.direction!; // rolling init direction        this.keep = this.config.keep!; // whether to keep rolling after mouse out area        this.paused = false; // keep state to pause the animation        // create element        this._createElement();        // init        this._init();        // set elements and instances        Cloud3d.list.push({ el: this.$el, container, instance: self } as never);    }    static _getMaxSpeed = (name: string) =>        ({ slow: 0.5, normal: 1, fast: 2 })[name] || 1;    static _getInitSpeed = (name: string) =>        ({ slow: 16, normal: 32, fast: 80 })[name] || 32;    // event listener    static _on(        el: HTMLElement | (Window & typeof globalThis) | undefined,        ev: string,        handler: any,        cap?: any,    ) {        if (el && el.addEventListener) {            el.addEventListener(ev, handler, cap);        }    }    /* instance property method */    // create elment    _createElement() {        // create container        const $el = document.createElement('div');        $el.className = this.config.containerClass!;        if (this.config.useContainerInlineStyles) {            $el.style.position = 'relative';            $el.style.width = `${2 * this.radius}px`;            $el.style.height = `${2 * this.radius}px`;        }        // create texts        this.items = [];        this.items.forEach((text, index) => {            const item = this._createTextItem(text, index);            $el.appendChild(item.el);            this.items.push(item);        });        this.$container.appendChild($el);        this.$el = $el;    }    // create a text    _createTextItem(item: any, index = 0) {        const itemEl = document.createElement('img');        itemEl.className = this.config.itemClass!;        if (this.config.useItemInlineStyles) {            itemEl.style.willChange = 'transform, opacity, filter';            itemEl.style.position = 'absolute';            itemEl.style.top = '50%';            itemEl.style.left = '50%';            itemEl.style.zIndex = `${index + 1}`;            itemEl.style.filter = 'alpha(opacity=0)';            itemEl.style.opacity = '0';            // itemEl.style.WebkitTransformOrigin = transformOrigin;            // itemEl.style.MozTransformOrigin = transformOrigin;            // itemEl.style.OTransformOrigin = transformOrigin;            itemEl.style.transformOrigin = '50% 50%';            // itemEl.style.WebkitTransform = transform;            // itemEl.style.MozTransform = transform;            // itemEl.style.OTransform = transform;            itemEl.style.transform = 'translate3d(-50%, -50%, 0) scale(1)';            itemEl.src = item.src;            itemEl.width = 200;            itemEl.style.transition = 'filter 500ms ease-in-out';            itemEl.style.filter = 'grayscale(1)';            itemEl.addEventListener('mouseover', () => {                itemEl.style.filter = 'grayscale(0)';            });            itemEl.addEventListener('mouseleave', () => {                itemEl.style.filter = 'grayscale(1)';            });        }        return {            el: itemEl,            ...this._computePosition(index), // distributed in appropriate place        };    }    // calculate appropriate place    _computePosition(index: number, random = false) {        const textsLength = this.items.length;        // if random `true`, It means that a random appropriate place is generated, and the position will be independent of `index`        if (random) index = Math.floor(Math.random() * (textsLength + 1));        const phi = Math.acos(-1 + (2 * index + 1) / textsLength);        const theta = Math.sqrt((textsLength + 1) * Math.PI) * phi;        return {            x: (this.size * Math.cos(theta) * Math.sin(phi)) / 2,            y: (this.size * Math.sin(theta) * Math.sin(phi)) / 2,            z: (this.size * Math.cos(phi)) / 2,        };    }    _requestInterval(fn: any, delay: number) {        const requestAnimFrame = (            (() => window.requestAnimationFrame) ||            ((callback, element) => {                window.setTimeout(callback, 1000 / 60);            })        )();        let start = new Date().getTime();        const handle = { value: 0 };        function loop() {            handle.value = requestAnimFrame(loop);            const current = new Date().getTime(),                delta = current - start;            if (delta >= delay) {                fn.call();                start = new Date().getTime();            }        }        handle.value = requestAnimFrame(loop);        return handle;    }    // init    _init() {        this.active = false; // whether the mouse is activated        this.mouseX0 =            this.initSpeed * Math.sin(this.direction * (Math.PI / 180)); // init distance between the mouse and rolling center x axis        this.mouseY0 =            -this.initSpeed * Math.cos(this.direction * (Math.PI / 180)); // init distance between the mouse and rolling center y axis        this.mouseX = this.mouseX0; // current distance between the mouse and rolling center x axis        this.mouseY = this.mouseY0; // current distance between the mouse and rolling center y axis        const isTouchDevice = window.matchMedia('(hover: hover)');        if (!isTouchDevice || isTouchDevice.matches) {            // mouseover            Cloud3d._on(this.$el, 'mouseover', () => {                this.active = true;            });            // mouseout            Cloud3d._on(this.$el, 'mouseout', () => {                this.active = false;            });            // mousemove            Cloud3d._on(                this.keep ? window : this.$el,                'mousemove',                (ev: MouseEvent) => {                    ev = ev || window.event;                    if (!this.$el) return;                    const rect = this.$el.getBoundingClientRect();                    this.mouseX =                        (ev.clientX - (rect.left + rect.width / 2)) / 5;                    this.mouseY =                        (ev.clientY - (rect.top + rect.height / 2)) / 5;                },            );        }        // update state regularly        this._next(); // init update state        this.interval = this._requestInterval(() => {            this._next.call(this);        }, 10);    }    // calculate the next state    _next() {        if (this.paused) {            return;        }        // if keep `false`, pause rolling after moving mouse out area        if (!this.keep && !this.active) {            this.mouseX =                Math.abs(this.mouseX - this.mouseX0) < 1                    ? this.mouseX0                    : (this.mouseX + this.mouseX0) / 2; // reset distance between the mouse and rolling center x axis            this.mouseY =                Math.abs(this.mouseY - this.mouseY0) < 1                    ? this.mouseY0                    : (this.mouseY + this.mouseY0) / 2; // reset distance between the mouse and rolling center y axis        }        let a =            -(                Math.min(Math.max(-this.mouseY, -this.size), this.size) /                this.radius            ) * this.maxSpeed;        let b =            (Math.min(Math.max(-this.mouseX, -this.size), this.size) /                this.radius) *            this.maxSpeed;        // inverse direction if enabled        if (this.config.reverseDirection) {            a = -a;            b = -b;        }        if (Math.abs(a) <= 0.01 && Math.abs(b) <= 0.01) return; // pause        // calculate offset        const l = Math.PI / 180;        const sc = [            Math.sin(a * l),            Math.cos(a * l),            Math.sin(b * l),            Math.cos(b * l),        ];        this.items.forEach((item: ItemType) => {            const rx1 = item.pos.x;            const ry1 = item.pos.y * sc[1] + item.pos.z * -sc[0];            const rz1 = item.pos.y * sc[0] + item.pos.z * sc[1];            const rx2 = rx1 * sc[3] + rz1 * sc[2];            const ry2 = ry1;            const rz2 = rz1 * sc[3] - rx1 * sc[2];            const per = (2 * this.depth) / (2 * this.depth + rz2); // todo            item.pos.x = rx2;            item.pos.y = ry2;            item.pos.z = rz2;            item.el.style.scale = per.toFixed(3);            let alpha: string | number = (per * per - 0.25) * 100;            alpha = (alpha > 1 ? 1 : alpha).toFixed(3);            const itemEl = item.el;            const left = (item.pos.x - itemEl.offsetWidth / 2).toFixed(2);            const top = (item.pos.y - itemEl.offsetHeight / 2).toFixed(2);            // itemEl.style.WebkitTransform = transform;            // itemEl.style.MozTransform = transform;            // itemEl.style.OTransform = transform;            itemEl.style.transform = `translate3d(${left}px, ${top}px, 0) scale(${itemEl.style.scale})`;            itemEl.style.filter = `alpha(opacity=${alpha})`;            itemEl.style.opacity = alpha;        });    }    public destroy() {        this.interval = null;        // clear in TagCloud.list        const index = Cloud3d.list.findIndex(            (e: ItemType) => e.el === this.$el,        );        if (index !== -1) Cloud3d.list.splice(index, 1);        // clear element        if (this.$container && this.$el) {            this.$container.removeChild(this.$el);        }    }}export default (els: any, items: Array<any>, options: CloudOptions) => {    if (typeof els === 'string') els = document.querySelectorAll(els);    if (!els.forEach) els = [els];    const instances: Cloud3d[] = [];    els.forEach((el: any) => {        if (el) {            instances.push(new Cloud3d(el, items, options));        }    });    return instances.length <= 1 ? instances[0] : instances;};